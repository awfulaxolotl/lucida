import { assertDefined } from '../util'
import { RoseTree, BasicRoseTree } from './RoseTree'

/**
 * NodeKey to uniquely identify a node
 *
 * This is generated by the TangledTree on
 * insertion.
 */
type NodeKey = number

/**
 * Node stored within the TangledTree
 *
 * This may look, weird -- a node is a rose tree?
 *
 * Let me explain!
 *
 * Each node contains its value and its children. In a
 * normalized implementation each child would be a node
 * key to the actual child.
 *
 * In this implementation each child is the actual
 * reference to the child. This avoids an internal map
 * lookup at the cost of memory leaks if we're not careful
 * to remove children from their parents during removal
 * from the tree.
 *
 * This means each node stays a valid rose subtree, where
 * it may be tangled up with other adjacent trees! Woah.
 */
type Node<T> = BasicRoseTree<T>

/**
 * TangledTree
 *
 * Two equivalent definitions:
 *
 * - A rose tree where a node may have multiple parents
 * - A rooted, directed, acyclic graph
 *
 * It can be untangled to get a proper tree where nodes
 * can have at most one parent.
 */
export class TangledTree<T> {
  private lastKey: NodeKey = Number.MIN_SAFE_INTEGER
  private roots: Set<NodeKey> = new Set()
  protected nodes: Map<NodeKey, Node<T>> = new Map()

  /**
   * Add node as a new root to the tangled tree
   *
   * This node will cease to be a root when a future
   * addition claims it as its child.
   *
   * @param value value to store in the tree
   * @param childrenKeys keys of children
   */
  public add(value: T, childrenKeys: NodeKey[] = []): NodeKey {
    const { nodes, roots, lastKey } = this

    const key = (this.lastKey = lastKey + 1)
    const children = childrenKeys.map(k => assertDefined(nodes.get(k)))

    nodes.set(key, { value, children })

    roots.add(key)
    for (const ck of childrenKeys) {
      roots.delete(ck)
    }

    return key
  }

  /**
   * Root of tangled tree
   *
   * Will return an exception if there are multiple roots,
   * which will happen in the middle of construction.
   */
  public root(): Node<T> {
    const { roots, nodes } = this
    this.assertRoot()

    const rootKey = Array.from(roots.values())[0]
    const rootNode = nodes.get(rootKey)

    return assertDefined(rootNode)
  }

  /**
   * Untangle to a proper tree
   *
   * Effectively splits and copies shared children:
   *
   *        ●                 ●
   *       ↙ ↘               ↙ ↘
   *      ●   ●   becomes   ●   ●
   *       ↘ ↙              ↓   ↓
   *        ●               ●   ●
   */
  public untangle(): RoseTree<T> {
    // It's a one liner! This is due to RoseTree's constructor
    // recursively copying its argument.
    return new RoseTree(this.root())
  }

  /**
   * Assert a single root
   */
  public assertRoot(): void {
    const { roots } = this

    if (roots.size !== 1) {
      throw new TypeError('TangledTree requires one and only one root')
    }
  }
}
